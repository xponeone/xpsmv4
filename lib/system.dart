import 'dart:collection';
import 'dart:io';
import 'dart:convert';
import 'dart:isolate';
import 'package:flutter/material.dart';
import 'package:path/path.dart' as p;
import 'package:resolve_windows_shortcut/resolve_windows_shortcut.dart';
import 'package:xpsmv4/dsftool.dart';
import 'alert.dart';
import 'package:latlong2/latlong.dart';
import 'package:flutter_map/flutter_map.dart';
import 'package:crypto/crypto.dart';

List<Scenery> sceneries = [];
List<String> lib = [];
late Function updateFunc;
String path = '';
int version = 12;
SceneryTypes? selectType;
final runDir = p.dirname(Platform.resolvedExecutable) + Platform.pathSeparator;
final jsonHeader =
    "// -+-+-+-+-+-+-+-+-+-IMPORTANT-+-+-+-+-+-+-+-+-+-\n// This file is a cache file automatically generated by the XPSM.\n// You can delete this file, but it will be regenerated when XPSM runs.\n// If you delete this file, XPSM loading time may increase.\n// If this file is modified incorrectly and cannot be read properly,\n// the modifications will be discarded.\n// -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n\n";

class Progress {
  double progress;
  String msg;
  Progress({required this.progress, required this.msg});
}

class Cache {
  SceneryTypes type;
  // Map<String, dynamic> dsf;
  Set<String> library;
  Map<String, dynamic>? group;
  Cache({required this.type, required this.library, required this.group});

  factory Cache.fromJSON(Map<String, dynamic> jsonData) {
    return Cache(
      type: SceneryTypes.fromString(jsonData['type']),
      // dsf: jsonData['dsf'],
      library: SplayTreeSet.from(jsonData['library']),
      group: jsonData['group'] ?? null,
    );
  }
}

class Airport {
  String name;
  String icao;
  SceneryTypes type;
  Airport({required this.name, required this.icao, required this.type});
}

class Scenery {
  String name;
  String path;
  SceneryTypes? type;
  bool active;
  bool selected;
  List<Scenery>? items;
  List<DSF> dsf = [];
  Set<String>? library;
  List<Airport> ap = [];
  int expand = 0;

  Scenery({required this.name, required this.path, this.type, this.active = true, this.selected = false, this.items}) {
    if (path == '') return;
    if (File('$path${Platform.pathSeparator}xpsm_cache.json').existsSync()) {
      print('$path${Platform.pathSeparator}xpsm_cache.json found!');
      try {
        Cache cache = Cache.fromJSON(jsonDecode(File('$path${Platform.pathSeparator}xpsm_cache.json').readAsStringSync().replaceAll(RegExp('^//.*\$', multiLine: true), '')));
        type = cache.type;
        library = cache.library;
        getAirport();
        return;
      } catch (e) {
        print('Failed to load json. ($path) $e');
      }
    }
    if (Directory('$path${Platform.pathSeparator}earth nav data').existsSync()) {
      for (final entity in Directory('$path${Platform.pathSeparator}earth nav data').listSync(recursive: true)) {
        if (p.extension(entity.path) == '.dsf') {
          dsf.add(DSF(path: entity.path));
        }
      }
      if (File('$path${Platform.pathSeparator}earth nav data${Platform.pathSeparator}apt.dat').existsSync()) {
        int airport = 0;
        int helipad = 0;
        for (final line in File('$path${Platform.pathSeparator}earth nav data${Platform.pathSeparator}apt.dat').readAsLinesSync()) {
          if (line.startsWith('1 ') || line.startsWith('16 ')) {
            List<String> split = line.split(RegExp(r'( |\t)+'));
            ap.add(Airport(name: split.skip(5).join(' '), icao: split[4], type: SceneryTypes.AIRPORT));
            airport++;
          } else if (line.startsWith('17 ')) {
            List<String> split = line.split(RegExp(r'( |\t)+'));
            ap.add(Airport(name: split.skip(5).join(' '), icao: split[4], type: SceneryTypes.HELIPAD));
            helipad++;
          }
        }
        if (airport > 0) {
          type = SceneryTypes.AIRPORT;
          saveCache();
          return;
        } else if (helipad > 0) {
          type = SceneryTypes.HELIPAD;
          saveCache();
          return;
        }
      }
      int TERT = 0, OBJT = 0, POLY = 0, NETW = 0;
      for (final d in dsf) {
        TERT += d.TERT;
        OBJT += d.OBJT;
        POLY += d.POLY;
        NETW += d.NETW;
      }
      if (OBJT > 0) {
        type = SceneryTypes.CITY;
        saveCache();
        return;
      } else if (TERT > 0) {
        if (POLY + NETW > 0) {
          type = SceneryTypes.MESH;
          saveCache();
          return;
        }
        type = SceneryTypes.PHOTOREAL;
        saveCache();
        return;
      } else if (POLY + NETW > 0) {
        type = SceneryTypes.OVERLAY;
        saveCache();
        return;
      }
    } else if (File('$path${Platform.pathSeparator}library.txt').existsSync()) {
      type = SceneryTypes.LIBRARY;
      saveCache();
      return;
    }
    type = SceneryTypes.UNKNOWN;
    saveCache();
    return;
  }

  void getAirport() {
    if (File('$path${Platform.pathSeparator}earth nav data${Platform.pathSeparator}apt.dat').existsSync()) {
      for (final line in File('$path${Platform.pathSeparator}earth nav data${Platform.pathSeparator}apt.dat').readAsLinesSync()) {
        if (line.startsWith('1 ') || line.startsWith('16 ')) {
          List<String> split = line.split(RegExp(r'( |\t)+'));
          ap.add(Airport(name: split.skip(5).join(' '), icao: split[4], type: SceneryTypes.AIRPORT));
        } else if (line.startsWith('17 ')) {
          List<String> split = line.split(RegExp(r'( |\t)+'));
          ap.add(Airport(name: split.skip(5).join(' '), icao: split[4], type: SceneryTypes.HELIPAD));
        }
      }
    }
  }

  void saveCache() {
    Map<String, String> dsfHash = {};
    for (final d in dsf) {
      dsfHash[p.basenameWithoutExtension(d.path)] = md5.convert(File(d.path).readAsBytesSync()).toString();
    }
    library = getLibrarySync();
    File('$path${Platform.pathSeparator}xpsm_cache.json').writeAsStringSync(jsonHeader + JsonEncoder.withIndent('\t').convert({"type": type.toString(), "library": library!.toList()}));
  }

  Set<String> getLibrarySync() {
    if (library == null) {
      Set<String> lib = {};
      for (final d in extract(dsf, 64)) {
        lib.addAll(d.getLibrarySync());
      }
      library = SplayTreeSet.from(lib);
    }
    return library!;
  }

  Future<Set<String>> getLibrary() async {
    if (library == null) {
      final rPort = ReceivePort();
      try {
        await Isolate.spawn((port) async {
          final futures = extract(dsf, 128).map((d) => d.getLibrary()).toList();
          final results = await Future.wait(futures);
          Set<String> lib = {};
          for (final result in results) {
            lib.addAll(result);
          }
          port.send(lib);
        }, rPort.sendPort);
        library = await rPort.first;
        library = SplayTreeSet.from(library!);
      } finally {
        rPort.close();
      }
    }
    return library!;
  }

  Widget getMap() {
    List<Polyline> runways = [];
    List<CircleMarker> helipads = [];
    List<Polygon> tiles = [];
    if (File('$path${Platform.pathSeparator}earth nav data${Platform.pathSeparator}apt.dat').existsSync()) {
      for (final line in File('$path${Platform.pathSeparator}earth nav data${Platform.pathSeparator}apt.dat').readAsLinesSync()) {
        if (line.startsWith('100 ')) {
          List<String> split = line.split(RegExp(r'( |\t)+'));
          runways.add(Polyline(
            points: [LatLng(double.parse(split[9]), (double.parse(split[10]))), LatLng(double.parse(split[18]), (double.parse(split[19])))],
            strokeWidth: 10,
            color: Colors.blue,
          ));
        } else if (line.startsWith('102 ')) {
          List<String> split = line.split(RegExp(r'( |\t)+'));
          helipads.add(CircleMarker(
            point: LatLng(double.parse(split[2]), (double.parse(split[3]))),
            radius: 5,
            color: Colors.green,
          ));
        }
      }
    }
    List<LatLng> points = [];
    for (final t in getTiles()) {
      double x = int.parse(t.substring(0, 3)).toDouble();
      double y = int.parse(t.substring(3)).toDouble();
      points.add(LatLng(x + 0.5, y + 0.5));
      tiles.add(Polygon(
        points: [LatLng(x, y), LatLng(x + 1, y), LatLng(x + 1, y + 1), LatLng(x, y + 1)],
        color: Colors.red.withOpacity(0.4),
        borderColor: Colors.red,
        borderStrokeWidth: 1,
      ));
    }
    print(tiles.length);
    if (runways.length + helipads.length + tiles.length > 0) {
      return FlutterMap(
        options: MapOptions(initialCenter: LatLng(0, LatLngBounds.fromPoints(points).center.longitude), initialZoom: 0),
        children: [
          TileLayer(
            urlTemplate: 'http://tile.openstreetmap.org/{z}/{x}/{y}.png',
          ),
          PolygonLayer(polygons: tiles),
          PolylineLayer(polylines: runways),
          CircleLayer(circles: helipads),
        ],
      );
    } else {
      return Container(
        color: Colors.black,
      );
    }
  }

  List<String> getTiles() {
    List<String> tiles = [];
    if (Directory('$path${Platform.pathSeparator}earth nav data').existsSync()) {
      for (final d in Directory('$path${Platform.pathSeparator}earth nav data').listSync(recursive: true)) {
        if (p.extension(d.path) == '.dsf') {
          tiles.add(p.basenameWithoutExtension(d.path));
        }
      }
    }
    return tiles;
  }

  String getAirportICAO() {
    String icao = '';
    try {
      for (final line in File('$path${Platform.pathSeparator}earth nav data${Platform.pathSeparator}apt.dat').readAsLinesSync()) {
        if (line.startsWith(RegExp(r'1(|6|7)( |\t)+'))) {
          List<String> split = line.split(RegExp(r'( |\t)+'));
          if (icao != '') icao += ', ';
          icao += split[4];
        }
      }
    } catch (e) {}
    return icao;
  }

  List<String> getAirportICAOList() {
    List<String> icaos = [];
    try {
      for (final line in File('$path${Platform.pathSeparator}earth nav data${Platform.pathSeparator}apt.dat').readAsLinesSync()) {
        if (line.startsWith(RegExp(r'1(|6|7)( |\t)+'))) {
          List<String> split = line.split(RegExp(r'( |\t)+'));
          icaos.add(split[4]);
        }
      }
    } catch (e) {}
    return icaos;
  }

  String getAirportName() {
    String name = '';
    try {
      for (final line in File('$path${Platform.pathSeparator}earth nav data${Platform.pathSeparator}apt.dat').readAsLinesSync()) {
        if (line.startsWith(RegExp(r'1(|6|7)( |\t)+'))) {
          List<String> split = line.split(RegExp(r'( |\t)+'));
          if (name != '') name += ', ';
          name += split.skip(5).join(' ');
        }
      }
    } catch (e) {}
    return name;
  }

  List<String> getAirportNameList() {
    List<String> names = [];
    try {
      for (final line in File('$path${Platform.pathSeparator}earth nav data${Platform.pathSeparator}apt.dat').readAsLinesSync()) {
        if (line.startsWith(RegExp(r'1(|6|7)( |\t)+'))) {
          List<String> split = line.split(RegExp(r'( |\t)+'));
          names.add(split.skip(5).join(' '));
        }
      }
    } catch (e) {}
    return names;
  }
}

Stream<Progress> init(update) async* {
  updateFunc = update;
  yield Progress(progress: 0.1, msg: 'Load setting');
  loadSetting(null);
  await for (var i in readCustomScenery()) {
    yield Progress(progress: 0.8 * i.progress, msg: i.msg);
  }
  yield Progress(progress: 0.9, msg: 'Sorting');
  sort();
}

Stream<Progress> refresh() async* {
  await for (var i in readCustomScenery()) {
    yield Progress(progress: 0.5 * i.progress, msg: i.msg);
  }
  yield Progress(progress: 0.9, msg: 'Sorting');
  sort();
}

void readLib(path) {
  final file = File('$path${Platform.pathSeparator}library.txt');
  if (file.existsSync()) {
    List<String> lines;
    try {
      lines = file.readAsLinesSync();
    } catch (e) {
      lines = file.readAsLinesSync(encoding: latin1);
    }
    lib.addAll(lines
        .where((e) => e.startsWith('EXPORT'))
        .map((e) => e.replaceAll(RegExp('^EXPORT(_RATIO(_SEASON\\s+.+?|)\\s+[0-9.]+|_SEASON\\s+.+?|_.+?(_SEASON\\s+.+?|)|)\\s+'), ''))
        .map((e) => e.replaceAll(RegExp('(?<=\\.(agb|agp|ags|dcl|fac|for|lin|net|obj|png|pol|str|ter)(?!\$))\\s+.*\$'), ''))
        .toList());
  }
}

Stream<Progress> readCustomScenery() async* {
  if (path != '') {
    sceneries.clear();
    if (version == 12) sceneries.add(Scenery(name: 'GLOBAL_AIRPORTS', path: '', type: SceneryTypes.GLOBAL));
    List<String> paths = await Directory(path).list(followLinks: true).map((e) => e.path).toList();
    for (var i = 0; i < paths.length; i++) {
      if (await FileSystemEntity.type(paths[i]) == FileSystemEntityType.directory) {
        yield Progress(progress: i / paths.length, msg: 'Reading ${paths[i]}');
        await Future.delayed(Duration.zero);
        sceneries.add(Scenery(name: p.basename(paths[i]), path: paths[i]));
        readLib(paths[i]);
      } else if (Platform.isWindows && await FileSystemEntity.type(paths[i]) == FileSystemEntityType.file && p.extension(paths[i]) == '.lnk') {
        String link = await File(paths[i]).resolveIfShortcut();
        yield Progress(progress: i / paths.length, msg: 'Reading $link');
        await Future.delayed(Duration.zero);
        sceneries.add(Scenery(name: p.basename(link), path: link));
        readLib(link);
      }
    }
  }
}

final order = [SceneryTypes.AIRPORT, SceneryTypes.HELIPAD, SceneryTypes.GLOBAL, SceneryTypes.CITY, SceneryTypes.OVERLAY, SceneryTypes.PHOTOREAL, SceneryTypes.MESH, SceneryTypes.LIBRARY, SceneryTypes.GROUP, SceneryTypes.UNKNOWN];

void sort() {
  sceneries.sort((a, b) {
    int typeComparison = order.indexOf(a.type!) - order.indexOf(b.type!);
    if (typeComparison == 0) {
      return a.name.compareTo(b.name);
    }
    return typeComparison;
  });
  updateFunc(() {});
}

void save(context) {
  File scenery_packs = File('$path${Platform.pathSeparator}scenery_packs.ini');
  String content = 'I\n1000 Version\nSCENERY\n\n';
  for (final s in sceneries) {
    if (s.items == null) {
      content += 'SCENERY_PACK';
      if (!s.active) content += '_DISABLED';
      if (s.type == SceneryTypes.GLOBAL) {
        content += ' *GLOBAL_AIRPORTS*';
      } else if (s.path.startsWith(path)) {
        content += ' Custom Scenery/${s.name}/';
      } else {
        content += ' ${s.path}/';
      }
      content += '\n';
    } else {
      for (final i in s.items!) {
        content += 'SCENERY_PACK';
        if (!i.active) content += '_DISABLED';
        if (i.type == SceneryTypes.GLOBAL) {
          content += ' *GLOBAL_AIRPORTS*';
        } else if (i.path.startsWith(path)) {
          content += ' Custom Scenery/${i.name}/';
        } else {
          content += ' ${i.path}/';
        }
        content += '\n';
      }
    }
  }
  scenery_packs.writeAsStringSync(content);
  alert(context, 'scenery_packs.ini has been saved.');
}

Stream<Progress> load() async* {
  sceneries.clear();
  File scenery_packs = File('$path${Platform.pathSeparator}scenery_packs.ini');
  if (await scenery_packs.exists()) {
    List<String> lines = await scenery_packs.readAsLines();
    for (var i = 0; i < lines.length; i++) {
      if (lines[i].startsWith('SCENERY_PACK Custom Scenery/')) {
        yield Progress(progress: i / lines.length, msg: 'Loading ${trim(lines[i].substring(28))}');
        await Future.delayed(Duration.zero);
        sceneries.add(Scenery(name: trim(lines[i].substring(28)), path: "$path${Platform.pathSeparator}${trim(lines[i].substring(28))}"));
      } else if (lines[i].startsWith('SCENERY_PACK *GLOBAL_AIRPORTS*')) {
        yield Progress(progress: i / lines.length, msg: 'Loading GLOBAL_AIRPORTS');
        await Future.delayed(Duration.zero);
        sceneries.add(Scenery(name: 'GLOBAL_AIRPORTS', path: '', type: SceneryTypes.GLOBAL));
      } else if (lines[i].startsWith('SCENERY_PACK ')) {
        yield Progress(progress: i / lines.length, msg: 'Loading ${trim(lines[i].substring(13))}');
        await Future.delayed(Duration.zero);
        sceneries.add(Scenery(name: p.basename(trim(lines[i].substring(13))), path: trim(lines[i].substring(13))));
      } else if (lines[i].startsWith('SCENERY_PACK_DISABLED Custom Scenery/')) {
        yield Progress(progress: i / lines.length, msg: 'Loading ${trim(lines[i].substring(37))}');
        await Future.delayed(Duration.zero);
        sceneries.add(Scenery(name: trim(lines[i].substring(37)), path: "$path${Platform.pathSeparator}${trim(lines[i].substring(37))}", active: false));
      } else if (lines[i].startsWith('SCENERY_PACK_DISABLED *GLOBAL_AIRPORTS*')) {
        yield Progress(progress: i / lines.length, msg: 'Loading GLOBAL_AIRPORTS');
        await Future.delayed(Duration.zero);
        sceneries.add(Scenery(name: 'GLOBAL_AIRPORTS', path: '', type: SceneryTypes.GLOBAL, active: false));
      } else if (lines[i].startsWith('SCENERY_PACK_DISABLED ')) {
        yield Progress(progress: i / lines.length, msg: 'Loading ${trim(lines[i].substring(22))}');
        await Future.delayed(Duration.zero);
        sceneries.add(Scenery(name: p.basename(trim(lines[i].substring(22))), path: trim(lines[i].substring(22)), active: false));
      }
    }
  }
  updateFunc(() {});
}

bool loadSetting(context) {
  File configFile = File('${runDir}config.json');
  String lpath = path;
  if (configFile.existsSync()) {
    path = jsonDecode(configFile.readAsStringSync())['x-plane_path'];
    if (path.endsWith('11')) {
      version = 11;
    } else if (path.endsWith('12')) {
      version = 12;
    }
    path += '${Platform.pathSeparator}Custom Scenery';
  } else {
    alert(context, 'config.json is not exist.', color: Colors.redAccent);
  }
  if (lpath != path) return true;
  return false;
}

String trim(String str) {
  if (str.endsWith('\\') || str.endsWith('/')) {
    return str.characters.skipLast(1).string;
  } else {
    return str;
  }
}

void removeCache() {
  for (final d in Directory(path).listSync()) {
    if (File('${d.path}${Platform.pathSeparator}xpsm_cache.json').existsSync()) {
      File('${d.path}${Platform.pathSeparator}xpsm_cache.json').delete();
      print('${d.path}${Platform.pathSeparator}xpsm_cache.json deleted!');
    }
  }
}

List<T> extract<T>(List<T> list, int n) {
  if (n >= list.length) {
    return List.from(list);
  }

  final result = <T>[];
  final spacing = (list.length - 1) / (n - 1);

  for (var i = 0; i < n; i++) {
    final index = (i * spacing).round();
    result.add(list[index]);
  }

  return result;
}
